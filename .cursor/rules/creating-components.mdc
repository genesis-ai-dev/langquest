---
description: Guidelines for creating and updating components following components.build standards
alwaysApply: false
---

## Methodology

Follow the [components.build](https://www.components.build/) specification for building modern, composable, and accessible UI components. Use the [Composition Pattern](https://www.radix-ui.com/primitives/docs/guides/composition).

## Artifact Taxonomy

Understand the hierarchy of UI artifacts we work with:

1. **Primitive** - Lowest-level building block providing behavior and accessibility without styling (e.g., Radix UI Primitives)
2. **Component** - Styled, reusable UI unit that adds visual design to primitives (e.g., shadcn/ui components)
3. **Pattern** - Specific composition solving a UI/UX problem (e.g., form validation with inline errors)

## Core Principles

### Composability and Reusability

- Favor composition over inheritance
- Build components that can be combined and nested
- Expose clear API via props/slots for customization
- Make components reusable in different contexts

### Accessible by Default

- Accessibility is not optional - it's a baseline feature
- See the detailed [Accessibility](#accessibility) section below for implementation guidelines

### Customizability and Theming

- Avoid hard-coding visual styles that cannot be overridden
- Provide mechanisms for theming (CSS variables, className, style props)
- Come with sensible defaults but allow easy customization
- Use design tokens for visual values (see [Styling](#styling) section)

### Lightweight and Performant

- Minimize dependencies
- Avoid bloating with unnecessary logic
- Strive for good rendering and interaction performance
- Minimize unnecessary re-renders

## Existing Components & Library Selection

**Decision order when building features:**

1. **Check existing UI components** (in order):
   - [React Native Reusables](https://reactnativereusables.com/docs) - UI components
   - [React Native Primitives](https://rn-primitives.vercel.app/) - Radix primitives
   - [RNR Community Resources](https://github.com/founded-labs/react-native-reusables/blob/main/COMMUNITY_RESOURCES.md) - Community examples

2. **Check Expo SDK** - [Expo SDK docs](https://docs.expo.dev/versions/latest/) for native APIs (camera, file system, haptics, etc.)

3. **Only then** consider third-party libraries or custom components.

## Composition Patterns

### Children / Slots

- **Children** (implicit slot): JSX between opening/closing tags
- **Named slots**: Props like `icon`, `footer`, or `<Component.Slot>` subcomponents
- **Slot forwarding**: Pass DOM attributes/className/refs through to underlying element

### Render Props (Function-as-Child)

Use when parent must own data/behavior but consumer must fully control markup:

```tsx
<ParentComponent data={data}>
  {(item) => <ChildComponent key={item.id} {...item} />}
</ParentComponent>
```

### Compound Components

Use separate component imports to compose complex UI (shadcn-style):

```tsx
import {
  Card,
  CardHeader,
  CardContent,
  CardFooter
} from '@/components/ui/card';

<Card>
  <CardHeader>Title</CardHeader>
  <CardContent>Body</CardContent>
  <CardFooter>Actions</CardFooter>
</Card>;
```

### Controlled vs. Uncontrolled

- **Controlled**: Value driven by props, emits `onChange` (source of truth is parent)
- **Uncontrolled**: Holds internal state, may expose `defaultValue` and imperative reset
- Many inputs should support both patterns

### Polymorphism / asChild

Use `asChild` prop to allow component to render as a different element:

```tsx
<Button asChild>
  <Link href="/">Click me</Link>
</Button>
```

This renders as `<Link>` instead of `<button>`, preserving all Button behavior.

## Accessibility

### Keyboard Navigation

- Document and implement keyboard map for every interactive component
- Support standard patterns: `Tab`, `Arrow keys`, `Home/End`, `Escape`
- Ensure all interactive elements are keyboard accessible

### Focus Management

- Rules for initial focus, roving focus, focus trapping
- Focus return on teardown (e.g., modals)
- Focus indicators visible and clear

### ARIA Attributes

- Use semantic HTML elements (`<button>`, `<ul>/<li>`, etc.)
- Augment with ARIA when necessary:
  - `role` - Communicate semantics (`role="menu"`)
  - `aria-*` states - State (`aria-checked`, `aria-expanded`)
  - `aria-*` properties - Relationships (`aria-controls`, `aria-labelledby`)

### Color Contrast

- Ensure sufficient color contrast for text and interactive elements
- Don't rely solely on color to convey information

## Implementation Notes

### Styling

- Don't use margin (`m-*` properties in tailwind), use `View`s with flex (`flex`), flex gap (`gap-*`), and flex direction (`flex-[row|col]`).
- Don't concatenate tailwind classnames with template strings, always use the `cn` utility in `utils/styleUtils.ts`.
- Don't use Tailwind leading-none or anything with a line-height less than 1.3, as it causes text clipping.
- Use **variants** for discrete style/behavior permutations (e.g., `size="sm|md|lg"`, `tone="neutral|destructive"`). Variants are not separate components.
- Use **design tokens** (CSS variables) for theming: `--color-bg`, `--radius-md`, `--space-2`
- Support **className** merging for customization
- Components should be **headless** (behavior only) or **styled** (default visual design but override-friendly)

### Icons

- When looking for a suitable icon, use the lucide-icons MCP.
- Import icons from `lucide-react-native` with `Icon` suffix: `MailIcon`, `BellIcon`.
- Use the `Icon` component from `components/ui/icon.tsx` with the `as` prop to render icons, ex. `<Icon as={MailIcon} />`.

- **Loading Indicators**: Always use `ActivityIndicator` from `react-native` for loading states. Don't use custom spinners or loading icons like `Loader2Icon` with animations.

### React 19

- Don't use `React.forwardRef` anymore. In React 19, components can accept `ref` as a regular prop directly. Simply add `ref` to your component's props interface and use it directly.

### Colors accessed in JavaScript

Use `useThemeColor` hook from `components` for colors in JavaScript (not Tailwind classes) to support dark/light mode. In non-component contexts, use `getThemeColor`.

### Worklet Threading

Use `scheduleOnRN` from `react-native-worklets` (not `runOnJS` or `queueMicrotask`) to schedule work on the React Native thread. **CRITICAL**: Pass function references only, never inline arrow functions - these crash. Declare wrapper functions outside worklets and pass by reference. Example: `const updateState = (value) => setState(value);` then `scheduleOnRN(updateState, newValue)`.

## React Compiler & Memoization

**Reference**: [I tried React Compiler today, and guess what...](https://www.developerway.com/posts/i-tried-react-compiler)

While React Compiler can automatically memoize components, it has limitations and doesn't solve all re-render problems. Understanding memoization patterns is still essential:

- **Mutation Hooks**: When using hooks like `useMutation` (e.g., from TanStack Query), extract the `mutate` function from the returned object rather than using the entire object as a dependency. The returned object itself is not memoized, but `mutate` is.

- **Dynamic Lists**: For lists rendered with `.map()`, always use stable, unique keys (not array indices). Extract list items into separate components when they contain complex JSX - this helps the compiler optimize them.

- **Children Props**: Components that accept `children` props are harder for the compiler to optimize. Prefer composition patterns like passing elements as props or using render props when performance matters.

- **Manual Memoization**: Don't assume React Compiler handles everything. For performance-critical components, you may still need `React.memo`, `useMemo`, or `useCallback`. The compiler shows components as "memoized" in DevTools, but this doesn't guarantee they won't re-render unnecessarily.

- **Composition Over Memoization**: When dealing with re-render issues, prefer composition techniques (moving state down, splitting contexts, extracting components) over manual memoization when possible.

- **ESLint Disable Comments**: Never use `// eslint-disable-next-line` or similar ESLint disable comments in your code. These comments prevent React Compiler from properly analyzing and optimizing your code. If ESLint flags an issue, fix the underlying problem rather than suppressing the warning. For legitimate cases where a dependency should be excluded (like stable functions or refs), refactor the code to make the stability explicit rather than disabling the exhaustive-deps rule.

- **React Native Reanimated Shared Values**: When working with React Native Reanimated's `useSharedValue`, use the `.get()` and `.set()` methods instead of accessing `.value` directly. This is the React Compiler-compliant API that avoids the need for refs or workarounds. Example:

```tsx
function App() {
  const sv = useSharedValue(100);

  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return { width: sv.get() * 100 };
  });

  const handlePress = () => {
    sv.set(withTiming(200, { duration: 300 }));
  };
}
```

This eliminates the need for refs (`useRef`) and `useEffect` when modifying shared values in inline handlers, as React Compiler treats direct `.value` access as immutable mutations.

### Types and Props API

- **TypeScript**: Ship with comprehensive types for maximum safety and autocomplete
- **Props API**: Stable, typed, documented with defaults and a11y ramifications
- Support both **controlled** and **uncontrolled** patterns where applicable (see [Controlled vs. Uncontrolled](#controlled-vs-uncontrolled))
- Document all props: name, type, default, required, description
- Document purpose, usage, accessibility notes (keyboard controls, ARIA attributes), and customization options

### Data Attributes

Use data attributes for styling hooks and state:

- `data-slot` - Identify component parts for styling
- `data-state` - Indicate component state (open, closed, checked, etc.)
- `data-disabled`, `data-selected`, etc. - State indicators

Example:

```tsx
<View data-slot="trigger" data-state={isOpen ? 'open' : 'closed'}>
```
