---
description: Guidelines to follow when writing new components & pages/views
alwaysApply: false
---

## Methodology

Use the [Composition Pattern](https://www.radix-ui.com/primitives/docs/guides/composition).

## Existing Components

Before creating a new UI component, check these resources for existing components and primitives that can be used or adapted:

- [React Native Reusables](https://reactnativereusables.com/docs) - Official documentation
- [React Native Primitives](https://rn-primitives.vercel.app/) - Radix UI primitives for React Native
- [React Native Reusables - Community Resources](https://github.com/founded-labs/react-native-reusables/blob/main/COMMUNITY_RESOURCES.md) - Community-contributed components and examples (ignore the drawer suggestion)

## Icons

- When looking for a suitable icon, use the lucide-icons MCP.
- Always import icons from `lucide-react-native` using the suffix `Icon` ex. `MailIcon`, `BellIcon` not `Mail` or `Bell`.
- Use the `Icon` component from `components/ui/icon.tsx` with the `as` prop to render icons, ex. `<Icon as={MailIcon} />`.

- **Loading Indicators**: Always use `ActivityIndicator` from `react-native` for loading states. Don't use custom spinners or loading icons like `Loader2Icon` with animations.

## Implementation Notes

- **Library Selection**: Before reaching for a third-party library, check the [Expo SDK documentation](https://docs.expo.dev/versions/latest/) for first-party solutions. Expo provides well-maintained, cross-platform APIs for many common needs (camera, file system, haptics, etc.) that integrate seamlessly with the Expo ecosystem.

- Don't use margin (`m-*` properties in tailwind), use views with flex (`flex`), flex gap (`gap-*`), and flex direction (`flex-[row|col]`).

- Don't concatenate tailwind classnames with template strings, always use the `cn` utility in `utils/styleUtils.ts`.

- Don't use Tailwind leading-none or actually anything that would have a line-height of less than 1.3, because it causes text clipping.

- **React 19**: Don't use `React.forwardRef` anymore. In React 19, components can accept `ref` as a regular prop directly. Simply add `ref` to your component's props interface and use it directly.

- **Colors accessed in JavaScript**: When using colors in JavaScript (not in Tailwind classes), always use the `useThemeColor` hook from `components` to ensure proper dark and light mode color switching automatically. In non-component contexts, use `getThemeColor` which gets the theme at the time the function is run.

- **Worklet Threading**: Don't use `runOnJS` from `react-native-reanimated`. Instead, use `react-native-worklets` for scheduling work on the React Native thread from worklets. Don't use `queueMicrotask` directly - always use `scheduleOnRN` from `react-native-worklets` to defer state updates and ensure they run on the React Native thread. **CRITICAL**: When using `scheduleOnRN`, you MUST pass function references (named functions declared outside the worklet), never anonymous functions or arrow functions inline - these will cause crashes. Always declare wrapper functions outside your worklet and pass them by reference. Example: Declare `const updateState = (value) => setState(value);` outside the worklet, then use `scheduleOnRN(updateState, newValue)`.

## React Compiler & Memoization

**Reference**: [I tried React Compiler today, and guess what...](https://www.developerway.com/posts/i-tried-react-compiler)

While React Compiler can automatically memoize components, it has limitations and doesn't solve all re-render problems. Understanding memoization patterns is still essential:

- **Mutation Hooks**: When using hooks like `useMutation` (e.g., from TanStack Query), extract the `mutate` function from the returned object rather than using the entire object as a dependency. The returned object itself is not memoized, but `mutate` is.

- **Dynamic Lists**: For lists rendered with `.map()`, always use stable, unique keys (not array indices). Extract list items into separate components when they contain complex JSX - this helps the compiler optimize them.

- **Children Props**: Components that accept `children` props are harder for the compiler to optimize. Prefer composition patterns like passing elements as props or using render props when performance matters.

- **Manual Memoization**: Don't assume React Compiler handles everything. For performance-critical components, you may still need `React.memo`, `useMemo`, or `useCallback`. The compiler shows components as "memoized" in DevTools, but this doesn't guarantee they won't re-render unnecessarily.

- **Composition Over Memoization**: When dealing with re-render issues, prefer composition techniques (moving state down, splitting contexts, extracting components) over manual memoization when possible.

- **ESLint Disable Comments**: Never use `// eslint-disable-next-line` or similar ESLint disable comments in your code. These comments prevent React Compiler from properly analyzing and optimizing your code. If ESLint flags an issue, fix the underlying problem rather than suppressing the warning. For legitimate cases where a dependency should be excluded (like stable functions or refs), refactor the code to make the stability explicit rather than disabling the exhaustive-deps rule.
